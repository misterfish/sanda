process.exit (1) 
//  @dep ifFunction
//  @dep bind

// --- 'nieuw' ones fit really well into final part of laat, by the way.

if (obj.speak) obj.speak()

whenOk__ (
    bindTry (obj, 'speak'),
    invoke,
)

whenOk__ (
    bindTry (obj, 'speak'),
    x => x ()
)

bindTry (obj, 'speak') | whenOk (invoke)
whenBind (obj, 'speak') | invoke
invokeWhenBind (obj, 'speak')
whenBindInvoke (obj, 'speak')
invokeIfCan (obj, 'speak')
whenCanInvoke (obj, 'speak') // no

bindTry (obj, 'speak') | invokeIfOk

if (this.parseFormData) formData = this.parseFormData(formData);
// first make immutable:

if (this.parseFormData)
    newFormData = this.parseFormData(formData);

// const newFormData = invokeIfCan (this, 'parseFormData', formData, ... else ??)

const newFormData_1 = bindTry (this, 'parseFormData') | ifOk (
    invoke,
    () => formData,
)

const newFormData_2 = [this, 'parseFormData'] | whenBind (invoke1 (formData))

// nooo
// const newFormData = bindTry (this, 'parseFormData') | ifOk (
//     invoke,
//     < formData
// )

const newFormData_3 = bindTry (this, 'parseFormData') | invoke1IfOk (formData)

if(this.model){
  this.model.set(this.serializeForm());
}

bindTry (this, 'model') | whenOk (
  it => it.set (this.serializeForm())
)

bindTry (this, 'model') | whenOk (
  dot1 ('set', (this.serializeForm()))
)

/*
if (this.startupCallback) {
    this.startupCallback();
}

this.startupCallback
| ifOk (callOn (this))

this.startupCallback
| ifOk (call (this))

ifOk__ (
    this.startupCallback,
    f => f.call (this),
)

ifOk__ (
    this.startupCallback,
    callOn (this),
)

ifOk__ (
    this.startupCallback,
    call (this),
)

ifOk__ (
    this.startupCallback,
    bind (this) >> call,
)

this.startupCallback
| ifOk (f => f.call (this))

'startupCallback'
| ifHasOn (this, call)

'startupCallback'
| ifBind (this, call)

invokeIfHas (this, 'startupCallback')
invoke1IfHas (this, 'startupCallback', 10)

ifBind (this, 'startupCallback', call)

*/


/*
 * invokeIfCanElse
 * if (canBind
function getSelection() {
        let txt = (window.getSelection)
        ? window.getSelection()
        : document.selection.createRange().text;

}

function getSelection() {
    const txt = 'getSelection' | window | ifBind (
        invoke,
        () => document.selection.createRange().text,
    )

    const gebonden = bind (window, 'getSelection')
    const txt = gebonden | ifOk (
        invoke,
        () => document.selection.createRange().text,
    )

    const txt = gebonden | invokeIfOkElse (
        () => document.selection.createRange().text,
    )

    const txt = [window, 'getSelection'] | ifBind (
        invoke,
        () => document.selection.createRange().text,
    )

    const txt =
        bind (window, 'getSelection')
        | ifOk (
            invoke,
            () => document.selection.createRange().text,
        )

// have to decide whether bind fails or returns undefined.
// probably fails. (see bind hard test)
//

in racket, one-armed if is when.



		isValidPgn:function(pgn) {
		    var pattern = new RegExp(/^[\d]{8,9}$/g); // 8-9 digits

		    if (!pattern.test(pgn)) {
				return false;
			}

			var total = 0;
			pgn.split('').forEach(function(elem, index, array) {
		    	if (index === array.length - 1) {
		    		total += -1 * parseInt(elem);
		    	} else {
		    		total += (array.length - index) * parseInt(elem);
		    	}
			});

		    return total % 11 === 0; // 'elfproef'
		},
		serializeForm:function(){
			var $disabledFields = $("*[disabled]",this.el);
			$disabledFields.removeAttr("disabled");

			var formData = $('form',this.$el).serializeObject();

			$disabledFields.attr("disabled","disabled");

			if(this.parseFormData){
				formData = this.parseFormData(formData);
			}
			return formData;
		},

// --- flagsYes ('outSplit', 'sync')
const flagsYes = (...args) => args
    | map (x => [x, true])
    | fromPairs

// might need a form for cond with no target (see tests)

*/

// update would be good
// cond like in cond-> clojure macro.

const my = {
    parseFormData: formData => 'parsed ' + formData,
}

// if (my.parseFormData) {
//     formData = my.parseFormData(formData);
// }

; [my, 'parseFormData']
| ifBind (
    pass1 (formData),
    () => formData,
)
| log

; [my, 'parseFormData']
| whenBind (
    pass1 (formData),
)
| log

; [my, 'arseFormData']
| whenBind (
    pass1 (formData),
)
| log

ifBind__ (
    [my, 'parseFomData'],
    pass1 (formData),
    () => 'allen',
)
| log

// point-free of x => x.apply (null, xs)
// is not called apply, but passX.

// --- @todo
//
// xReplace should tell how many it replaced?
// but ifReplace gets ths count, good enough?


but shouldn't mixins be functional.
mixin takes instance as input and modifies it.


lenses should compose with >>.

see gcanti.
'new street name' | address.set (...) where address is a lens.

check RA.
functors, pointy functors
check Reader from monet, examples given in RA.


return lens.set(f(lens.get(s)), s)
// not really better.
s | lens.set (f (s | ('get' | bind (lens)))))
// if we can guarantee that this is never used?
s | lens.set (f (s | (lens.get))))




flatten2 from test.
from redux workshop.


const shouldTrigger = ({ threshold, synapses }) => {
    const sum = synapses.reduce(
        (amplitude, { weight, value }) => amplitude + (weight * value), 0);
    return sum >= threshold;
}


const takeTwo = ({ threshold, synapses }) => laat (
    [
        synapses | reduce (
            ((amplitude, { weight, value }) => amplitude + (weight * value))
            (0)
        )
    ],
    sum => sum | gte (threshold),
)



// const composeLeft = (...fs) => compose (... (fs | reverse))
const composeLeft = (...fs) => fs | reverse | applyN (compose)



const join = curry ((joinStr, xs) => xs.reduce (
    (acc, x) => acc | ifNotOk (
        () => x,
        acc => acc + joinStr + x,
    ),
    null,
))




elementAt n = last . take (n + 1)




would be good to sugar this:

const lockerState = x => x | cond ([
    [equals ('taken'), () => LockerState.Taken],
    [equals ('free'), () => LockerState.Free],
    [equals ('broken'), () => LockerState.Broken],
])

const lockerState = cond ([
    'taken' | condEquals (() => LockerState.Taken),
    'free' | condEquals (() => LockerState.Free),
    'broken' | condEquals (() => LockerState.Broken),
])

daggyX#cata takes care of this though.

But it also opens the door to some pretty powerful idioms.

if (isEven (x)) doThen (x); else doElse (x)

x | ifEven (doThen, doElse)


instead of 'b is not a function' i want the name of the function.

increased expressive power



jlongster.com



yes it's 'hideous' with the parentheses touching:
replace(/a/)('e')(str)

but with some spaces between them you might actually start to find it kind of pretty.

replace (/a/) ('e') (str)
str | replace (/a/) ('e')
str | ('e' | replace (/a/))
str | replace (/a/, 'e')


maybe laatStar and family could do away with the array.

laatDat is a mess, buggy.
args are functions, so it should resemble laatStar, but without recursive stuff, unless it's
laatDatStar.

0 | laatDat (
    [
        ifZero (_ => 10, _ => 20),
        minus (1),
    ],
    (_, a, b) => {
        console.log ('a', a)
        console.log ('b', b)
    },
)


found this:

laat (
    [
        n | ifZero (...),
        n | minus (1),
    ],
    (a, b) => [a, b],
)

the last part is just an array of the args, so actually you're just assembling an array.

n | listDat (
    ifZero (...),
    minus (1),
)

    const f = n => map (pass1 (n))
    const f = n => n | pass1 | map
    // --- xxx, can't flip it after this.
    const f = pass1 >> map

const listDat3 = (() => {
    const _ = n => n | pass1 | ramda.map
    const __ = pass1 >> ramda.map
    const ___ = curry (pass1 >> ramda.map)
//     return __
    return ___ | flipC
//     return curry ((a, b) => ___ (b, a))
}) ()


after composing, have to curry again.




docs
 length as a reduce function.
     const length = 0 | reduce (inc)



prepositions.
piping.
expressiveness.
doe, laat.
anaphoric structures.

frustrations with case statement, e.g. livescript.
 more expressive matching: separate predicate from value.


several examples of reductions, derivations.

sorry but to we switched ramda's gt(e) and lt(e).

composing with the >> / << operators is curried by default.




// const mappend = curry ((rhs, lhs) => lhs | cond ([
//     LT | identical | guard (_ => LT),
//     GT | identical | guard (_ => GT),
//     EQ | identical | guard (_ => rhs),
// ]))

though of course, we have cata.
